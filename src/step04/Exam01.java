/*주제 : 산술 연산자 사용 */

package step04;

public class Exam01{
  public static void main(String[]args){
    int v1 = 10;
    int v2 = 20;
    int result = v1 + v2; // -, *, /, % 사용 가능

    System.out.println(result);

    byte b = 10;  // 리터럴 값 저장 예외 규칙에 의해 컴파일 OK!
    //byte b = v1;  // 오류 !! 변수의 경우 비록 작은 값이라 할 지라도 허락하지 않는다.

    byte b1 = 10;
    byte b2 = 20;
    byte b3 = 10 + 20; // OK! 리터럴과 리터럴의 연산 결과는 리터럴로 취급한다.

    //byte b3 = b1 + b2; // 컴파일 오류! byte와 byte 변수의 결과를 저장하는데 왜 컴파일 오류가 발생하는가? => 자바에서는 byte, short, int 메모리의 값을 다룰 때 int로 취급한다.
    //byte b3 = b1 + 20; // 컴파일 오류! => 리터럴과 변수의 연산 결과는 변수로 취급된다. + 자바에서는 byte, short, int 메모리의 값을 다룰 때 int로 취급한다. => int + 리터럴
    //byte b3 = 10 + b2; // 컴파일 오류! => 리터럴 + int

    short s1 = 20;
    //short s3 = b1 + s1; //컴파일 오류! 이유? byte, short 메모리는 무조건 int 메모리로 취급된다.

    //정상적으로 저장하기 위해서는..
    int i1 = b1 + s1 ; // OK! 가능한 (배열을 다루지 않는 한) int를 쓰자.

  }
}

/*

1)
4바이트 리터럴 값을 byte, short 메모리에 저장하는 규칙?
- 메모리에 저장할 수 있다면 허락한다.

2)
4바이트 변수의 값을 byte, short 메모리에 저장할 때?
- 값을 저장할 수 있더라도 무조건 컴파일 오류!

=> 2)가 원래 정상. 1)가 예외인 것.

리터럴 값들의 연산 결과는 리터럴 값으로 취급한다.
  - 리터럴은 값은 연산을 하더라도 변하지 않는다. => 컴파일(번역) 과정에서 검증할 수 있다. (그 값을 알 수 있음(10 + 20 = 30))
  => 기존의 법칙 : 리터럴 값이 비록 4바이트라고 하더라도 메모리에 저장할 수 있다면, 허락한다.

byte 변수와 byte 변수의 연산 결과는?
- int이다.
- short와 short의 연산 결과도 int이다.
- 자바의 기본 연산은 int이다. = 자바에서는 byte, short, int 메모리의 값을 다룰 때 int로 취급한다.



  리터럴과 변수의 연산 결과는 변수로 취급된다.
  - 변수의 값에 따라 연산 결과가 달라지기 때문에
    메모리에 저장할 수 있는지 확실하지 않다.
    그래서 기본 크기 보다 작은 메모리에 저장하는 것을 허락하지 않는다.
    (if 함수로 지정되어 있을 경우 변수에 어떤 값이 들어올 수 알 수 없음???)

      */
