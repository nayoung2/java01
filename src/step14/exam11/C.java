package step14.exam11;

public class C extends B{
  @Override // <-- 컴파일러에게 오버라이드 검사 요청
  public void m2() {  // B에는 m2가 없지만 B가 A에게 상속받은 m2 사용
    System.out.println("C.m2()");
  }
  // 새 메서드 추가 (오버라이딩X)
  public void m4() {
    System.out.println("C.m4()");
  }
  public void test() {
    this.m3();  // this는 인스턴스 주소값을 저장하는 변수일 뿐, 클래스를 가리키는게 아니다! ("이 클래스"를 의미하지 X)
    this.m2();

    // super : 재정의(Override)하기 전에 메소드.
    // => 지정된 메서드를 수퍼 클래스부터 상위 클래스로 찾아봐라! (C의 경우 B -> A)


    // 수퍼 클래스부터 계층 구조 위로 따라가면서 해당 메서드를 찾아라!
    super.m2(); // <-- 현재 클래스에 정의된 m2()는 무시하고
                // 상위 클래스부터 위쪽으로 m2()를 찾는다.
    super.m1(); // <-- 현재 클래스에 메서드가 있든 없든 상관없이
                // 상위 클래스부터 위쪽으로 m1()을 찾는다.
    //super.super.m1(); // 오류! super는 부모 클래스를 가리키는 것이 아니다. (super.super라는게 존재할 수 X)
    //super.m4(); // 오류! 상위 클래스부터 그 위로 따라 올라가면서 메서드를 찾는데,
                  // 상위 클래스에는 아무리 올라가도 m4가 없다.
    this.m4(); // <--- 현재 클래스부터 상위 클래스로 따라 올라가면서
              // 메서드를 찾는다.
  }
}

// 의미
// => this 레퍼런스에 저장된 인스턴스를 가지고 m3() 메서드를 호출한다.
// => m3 메서드 호출 과정
// 1) 현재 클래스에서 찾아본다
// 2) 없으면 상속받은 상위 클래스에서 찾아본다.(접근 권한이 있을 때)
// 3) 없다면 상위 클래스의 상위 클래스를 찾아본다.
// 4) ...(계속)

//참고!
// => 메서드를 호출할 때 마다 클래스 계층 구조(class hierarchy)를
// 훑기 때문에 C와 같은 functional 언어보다 (객체 지향 언어가) 실행 속도가 느리다.  // 현재 class가 아니라 상위 클래스에서도 찾기 때문에...
                                                                                    // 또한 자바나 C# 버추얼머신 위에서 돌아가기 때문에 또 느리다..
                                                                                    // 객체 지향은 속도보다 source code의 관리를 위함
